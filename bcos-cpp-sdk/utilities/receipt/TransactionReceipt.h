// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 3.0.3.
// **********************************************************************

#pragma once
#include "bcos-cpp-sdk/utilities/tx/tars/tup/Tars.h"
#include "bcos-cpp-sdk/utilities/tx/tars/tup/TarsJson.h"
#include <bcos-crypto/interfaces/crypto/Hash.h>
#include <boost/asio/detail/socket_ops.hpp>
#include <boost/endian/conversion.hpp>
#include <map>
#include <string>
#include <vector>

namespace bcostars
{
using namespace std;
struct LogEntry : public tars::TarsStructBase
{
public:
    static string className() { return "bcostars.LogEntry"; }
    static string MD5() { return "62d086d520cb1c44d615aec11186ef08"; }
    void resetDefautlt()
    {
        address = "";
        topic.clear();
        data.clear();
    }
    template <typename WriterT>
    void writeTo(tars::TarsOutputStream<WriterT>& _os) const
    {
        if (address != "")
        {
            _os.write(address, 1);
        }
        if (topic.size() > 0)
        {
            _os.write(topic, 2);
        }
        if (data.size() > 0)
        {
            _os.write(data, 3);
        }
    }
    template <typename ReaderT>
    void readFrom(tars::TarsInputStream<ReaderT>& _is)
    {
        resetDefautlt();
        _is.read(address, 1, false);
        _is.read(topic, 2, false);
        _is.read(data, 3, false);
    }
    [[nodiscard]] tars::JsonValueObjPtr writeToJson() const
    {
        tars::JsonValueObjPtr p = new tars::JsonValueObj();
        p->value["address"] = tars::JsonOutput::writeJson(address);
        p->value["topic"] = tars::JsonOutput::writeJson(topic);
        p->value["data"] = tars::JsonOutput::writeJson(data);
        return p;
    }
    ostream& display(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.display(address, "address");
        _ds.display(topic, "topic");
        _ds.display(data, "data");
        return _os;
    }
    ostream& displaySimple(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.displaySimple(address, true);
        _ds.displaySimple(topic, true);
        _ds.displaySimple(data, false);
        return _os;
    }

public:
    std::string address;
    vector<vector<tars::Char> > topic;
    vector<tars::Char> data;
};
inline bool operator==(const LogEntry& l, const LogEntry& r)
{
    return l.address == r.address && l.topic == r.topic && l.data == r.data;
}
inline bool operator!=(const LogEntry& l, const LogEntry& r)
{
    return !(l == r);
}

struct TransactionReceiptData : public tars::TarsStructBase
{
public:
    static string className() { return "bcostars.TransactionReceiptData"; }
    static string MD5() { return "2e0147a8f94f43a2c1d0113c0432886e"; }
    TransactionReceiptData() { resetDefault(); }
    void resetDefault()
    {
        version = 0;
        gasUsed = "";
        contractAddress = "";
        status = 0;
        output.clear();
        logEntries.clear();
        blockNumber = 0;
    }
    template <typename WriterT>
    void writeTo(tars::TarsOutputStream<WriterT>& _os) const
    {
        _os.write(version, 1);
        if (gasUsed != "")
        {
            _os.write(gasUsed, 2);
        }
        if (contractAddress != "")
        {
            _os.write(contractAddress, 3);
        }
        if (status != 0)
        {
            _os.write(status, 4);
        }
        if (output.size() > 0)
        {
            _os.write(output, 5);
        }
        if (logEntries.size() > 0)
        {
            _os.write(logEntries, 6);
        }
        if (blockNumber != 0)
        {
            _os.write(blockNumber, 7);
        }
    }
    template <typename ReaderT>
    void readFrom(tars::TarsInputStream<ReaderT>& _is)
    {
        resetDefault();
        _is.read(version, 1, true);
        _is.read(gasUsed, 2, false);
        _is.read(contractAddress, 3, false);
        _is.read(status, 4, false);
        _is.read(output, 5, false);
        _is.read(logEntries, 6, false);
        _is.read(blockNumber, 7, false);
    }
    [[nodiscard]] tars::JsonValueObjPtr writeToJson() const
    {
        tars::JsonValueObjPtr p = new tars::JsonValueObj();
        p->value["version"] = tars::JsonOutput::writeJson(version);
        p->value["gasUsed"] = tars::JsonOutput::writeJson(gasUsed);
        p->value["contractAddress"] = tars::JsonOutput::writeJson(contractAddress);
        p->value["status"] = tars::JsonOutput::writeJson(status);
        p->value["output"] = tars::JsonOutput::writeJson(output);
        p->value["logEntries"] = tars::JsonOutput::writeJson(logEntries);
        p->value["blockNumber"] = tars::JsonOutput::writeJson(blockNumber);
        return p;
    }
    [[nodiscard]] string writeToJsonString() const
    {
        return tars::TC_Json::writeValue(writeToJson());
    }
    ostream& display(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.display(version, "version");
        _ds.display(gasUsed, "gasUsed");
        _ds.display(contractAddress, "contractAddress");
        _ds.display(status, "status");
        _ds.display(output, "output");
        _ds.display(logEntries, "logEntries");
        _ds.display(blockNumber, "blockNumber");
        return _os;
    }
    ostream& displaySimple(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.displaySimple(version, true);
        _ds.displaySimple(gasUsed, true);
        _ds.displaySimple(contractAddress, true);
        _ds.displaySimple(status, true);
        _ds.displaySimple(output, true);
        _ds.displaySimple(logEntries, true);
        _ds.displaySimple(blockNumber, false);
        return _os;
    }

    [[nodiscard]] bcos::crypto::HashType hash(bcos::crypto::Hash::Ptr _hashImpl) const
    {
        auto hashContext = _hashImpl->init();
        // encode version
        int32_t networkVersion = boost::endian::native_to_big((int32_t)version);
        _hashImpl->update(hashContext, bcos::bytesConstRef((bcos::byte*)(&networkVersion),
                                           sizeof(networkVersion) / sizeof(uint8_t)));
        // gas used
        _hashImpl->update(
            hashContext, bcos::bytesConstRef((bcos::byte*)gasUsed.data(), gasUsed.size()));
        // address
        _hashImpl->update(hashContext,
            bcos::bytesConstRef((bcos::byte*)contractAddress.data(), contractAddress.size()));
        // status
        int32_t receiptStatus = boost::endian::native_to_big((int32_t)status);
        _hashImpl->update(hashContext, bcos::bytesConstRef((bcos::byte*)(&receiptStatus),
                                           sizeof(receiptStatus) / sizeof(uint8_t)));
        // output
        _hashImpl->update(
            hashContext, bcos::bytesConstRef((bcos::byte*)output.data(), output.size()));
        // logEntries
        for (const auto& log : logEntries)
        {
            // log address
            _hashImpl->update(hashContext,
                bcos::bytesConstRef((bcos::byte*)log.address.data(), log.address.size()));
            // log topic
            for (const auto& item : log.topic)
            {
                _hashImpl->update(
                    hashContext, bcos::bytesConstRef((bcos::byte*)item.data(), item.size()));
            }
            // log data
            _hashImpl->update(
                hashContext, bcos::bytesConstRef((bcos::byte*)log.data.data(), log.data.size()));
        }
        // block number
        int64_t receiptBlockNumber = boost::endian::native_to_big((int64_t)blockNumber);
        _hashImpl->update(hashContext, bcos::bytesConstRef((bcos::byte*)(&receiptBlockNumber),
                                           sizeof(receiptBlockNumber) / sizeof(uint8_t)));
        auto hashResult = _hashImpl->final(hashContext);
        return hashResult;
    }

public:
    tars::Int32 version;
    std::string gasUsed;
    std::string contractAddress;
    tars::Int32 status;
    vector<tars::Char> output;
    vector<bcostars::LogEntry> logEntries;
    tars::Int64 blockNumber;
};
inline bool operator==(const TransactionReceiptData& l, const TransactionReceiptData& r)
{
    return l.version == r.version && l.gasUsed == r.gasUsed &&
           l.contractAddress == r.contractAddress && l.status == r.status && l.output == r.output &&
           l.logEntries == r.logEntries && l.blockNumber == r.blockNumber;
}
inline bool operator!=(const TransactionReceiptData& l, const TransactionReceiptData& r)
{
    return !(l == r);
}

struct TransactionReceipt : public tars::TarsStructBase
{
public:
    static string className() { return "bcostars.TransactionReceipt"; }
    static string MD5() { return "536d257977d784307824953e3cf16980"; }
    TransactionReceipt() { resetDefault(); }
    void resetDefault()
    {
        data.resetDefault();
        dataHash.clear();
        message = "";
    }
    template <typename WriterT>
    void writeTo(tars::TarsOutputStream<WriterT>& _os) const
    {
        _os.write(data, 1);
        if (dataHash.size() > 0)
        {
            _os.write(dataHash, 2);
        }
        if (message != "")
        {
            _os.write(message, 3);
        }
    }
    template <typename ReaderT>
    void readFrom(tars::TarsInputStream<ReaderT>& _is)
    {
        resetDefault();
        _is.read(data, 1, false);
        _is.read(dataHash, 2, false);
        _is.read(message, 3, false);
    }
    ostream& display(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.display(data, "data");
        _ds.display(dataHash, "dataHash");
        _ds.display(message, "message");
        return _os;
    }
    ostream& displaySimple(ostream& _os, int _level = 0) const
    {
        tars::TarsDisplayer _ds(_os, _level);
        _ds.displaySimple(data, true);
        _ds.displaySimple(dataHash, true);
        _ds.displaySimple(message, false);
        return _os;
    }

public:
    bcostars::TransactionReceiptData data;
    vector<tars::Char> dataHash;
    std::string message;
};
inline bool operator==(const TransactionReceipt& l, const TransactionReceipt& r)
{
    return l.data == r.data && l.dataHash == r.dataHash && l.message == r.message;
}
inline bool operator!=(const TransactionReceipt& l, const TransactionReceipt& r)
{
    return !(l == r);
}
using ReceiptDataUniquePtr = std::unique_ptr<TransactionReceiptData>;
using ReceiptUniquePtr = std::unique_ptr<TransactionReceipt>;
}  // namespace bcostars
